#!/usr/bin/env python3
"""Generate .github/copilot-instructions.md deterministically.

This tool is intentionally offline and deterministic. It extracts:
- Repo law pointers (RepoLaw K1, InlineMarkup-K1)
- Tool entrypoints under tools/*/run
- CI workflows under .github/workflows/*.yml

It writes:
- .github/copilot-instructions.md (authoritative)
- out/gen_copilot_instructions/report.json (receipt)

Policy:
- Strict autogen: the output file is entirely generated.
- Stable ordering and no timestamps.
"""

from __future__ import annotations

import argparse
import hashlib
import json
from pathlib import Path
from typing import Any, Dict, List, Tuple

import yaml


REPO_ROOT = Path(__file__).resolve().parents[2]


def sha256_text(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()


def read_yaml(path: Path) -> Any:
    return yaml.safe_load(path.read_text(encoding="utf-8"))


def find_frame(path: Path) -> Tuple[str, str]:
    """Return (graph_id, version) for a GF0 frame.yml."""
    g = read_yaml(path)
    if not isinstance(g, dict):
        raise ValueError(f"frame is not a mapping: {path}")
    gid = g.get("graph_id")
    ver = g.get("version")
    if not isinstance(gid, str) or not isinstance(ver, str) or not gid or not ver:
        raise ValueError(f"missing graph_id/version: {path}")
    return gid, ver


def list_tools() -> List[Dict[str, str]]:
    out: List[Dict[str, str]] = []
    tools_dir = REPO_ROOT / "tools"
    if not tools_dir.exists():
        return out

    for d in sorted([p for p in tools_dir.iterdir() if p.is_dir()], key=lambda p: p.name):
        run = d / "run"
        run_py = d / "run.py"
        if run.exists() and run.is_file():
            out.append({"id": d.name, "entrypoint": str(run.relative_to(REPO_ROOT))})
        elif run_py.exists() and run_py.is_file():
            out.append({"id": d.name, "entrypoint": str(run_py.relative_to(REPO_ROOT))})

    return out


def list_workflows() -> List[Dict[str, Any]]:
    wf_dir = REPO_ROOT / ".github" / "workflows"
    out: List[Dict[str, Any]] = []
    if not wf_dir.exists():
        return out

    for p in sorted(wf_dir.glob("*.yml"), key=lambda x: x.name):
        data = read_yaml(p)
        name = str(data.get("name") or p.name) if isinstance(data, dict) else p.name
        jobs = []
        if isinstance(data, dict) and isinstance(data.get("jobs"), dict):
            for jid, j in sorted(data["jobs"].items(), key=lambda kv: str(kv[0])):
                if not isinstance(j, dict):
                    continue
                jobs.append({
                    "id": str(jid),
                    "name": str(j.get("name") or ""),
                })
        out.append({"path": str(p.relative_to(REPO_ROOT)), "name": name, "jobs": jobs})

    return out


def render_markdown(report: Dict[str, Any]) -> str:
    laws = report.get("laws", {})
    tools = report.get("tools", [])
    workflows = report.get("workflows", [])

    lines: List[str] = []

    lines.append("<!-- AUTOGENERATED: do not edit by hand. -->")
    lines.append("# Copilot Instructions — framecodex")
    lines.append("")

    lines.append("## Project charter")
    lines.append("This repository is a deterministic publication + documentation pipeline over GF0 frames.")
    lines.append("Generated documentation and publication artifacts MUST be reproducible.")
    lines.append("")

    lines.append("## Non-negotiable invariants")
    lines.append("- Frames are the single source of truth (`frames/**/v*/frame.yml`).")
    lines.append("- Generated docs (`docs/**/README.md`, `docs/MANIFEST.json`) are produced by the pipeline, not edited manually.")
    lines.append("- `out/` is transient and MUST remain gitignored.")
    lines.append("")

    lines.append("## Repo laws (normative)")
    for key in sorted(laws.keys()):
        l = laws[key]
        lines.append(f"- **{key}**: `{l['graph_id']}` v{l['version']} (`{l['path']}`)")
    lines.append("")

    lines.append("## InlineMarkup-K1")
    lines.append("- InlineMarkup-K1 is a deterministic markup subset for freeform text fields.")
    lines.append("- Use `text.format: md-inline` for short inline text; `md-block` for paragraphs and code fences.")
    lines.append("- Raw HTML tags are disallowed and validated.")
    lines.append("")

    lines.append("## Golden gates (run before/after changes)")
    lines.append("- `tools/enforce_repo_law/run` (policy + validators)")
    lines.append("- `tools/render_docs/run` (regenerate docs deterministically)")
    lines.append("- `tools/no_diff/run` (reproducibility check)")
    lines.append("")

    lines.append("## Tool entrypoints")
    for t in tools:
        lines.append(f"- `{t['id']}`: `{t['entrypoint']}`")
    lines.append("")

    lines.append("## CI workflows")
    for wf in workflows:
        lines.append(f"- `{wf['path']}` — {wf.get('name','')}")
        for j in wf.get("jobs", []):
            jname = j.get("name") or ""
            suffix = f" — {jname}" if jname else ""
            lines.append(f"  - job `{j['id']}`{suffix}")
    lines.append("")

    lines.append("## How to work in this repo")
    lines.append("- Prefer editing source frames and tools; then regenerate docs.")
    lines.append("- If asked to change a generated README, locate its frame under `frames/**/v*/frame.yml` and edit there.")
    lines.append("- Keep builds deterministic: avoid timestamps, randomness, and network access in generators.")
    lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--out", default=str(REPO_ROOT / ".github" / "copilot-instructions.md"))
    args = ap.parse_args()

    out_path = Path(args.out)

    laws: Dict[str, Dict[str, str]] = {}

    # Canonical laws (best-effort; keep deterministic even if missing)
    law_paths = {
        "RepoLaw-K1": REPO_ROOT / "frames" / "repo" / "law" / "governance" / "repo-law-k1" / "v0.1.0" / "frame.yml",
        "InlineMarkup-K1": REPO_ROOT / "frames" / "repo" / "law" / "text" / "inline-markup-k1" / "v0.1.0" / "frame.yml",
    }

    for k in sorted(law_paths.keys()):
        p = law_paths[k]
        if p.exists():
            gid, ver = find_frame(p)
            laws[k] = {"graph_id": gid, "version": ver, "path": str(p.relative_to(REPO_ROOT))}
        else:
            laws[k] = {"graph_id": "", "version": "", "path": str(p.relative_to(REPO_ROOT))}

    report: Dict[str, Any] = {
        "tool": {"id": "gen_copilot_instructions", "version": "0.1.0"},
        "laws": laws,
        "tools": list_tools(),
        "workflows": list_workflows(),
    }

    md = render_markdown(report)

    # Write outputs deterministically.
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(md, encoding="utf-8", newline="\n")

    receipt_dir = REPO_ROOT / "out" / "gen_copilot_instructions"
    receipt_dir.mkdir(parents=True, exist_ok=True)
    (receipt_dir / "report.json").write_text(json.dumps({**report, "sha256": sha256_text(md)}, indent=2, sort_keys=True) + "\n", encoding="utf-8")


if __name__ == "__main__":
    main()
